// ADVECTION STEP:
// Transports color from the source texture along the velocity field.
// Does so by travelling back along the velocity field by a time step
// then grabbing the color from that old position and moving it to the
// new position. (Euler Backward Method)

#version 430 core
layout (local_size_x = 16, local_size_y = 16) in; // workgroup size
//note: 1024 minimum maximum guaranteed by opengl. Test with 32x32

layout (rg32f, binding = 0) uniform readonly image2D velocityField;
layout (rgba32f, binding = 1) uniform readonly image2D inDyeTex;  //last frame's dye texture
layout (rgba32f, binding = 2) uniform writeonly image2D outDyeTex; //new advected dye texture

uniform float deltaTime;
uniform float dissipation;

// BILERP -- samples four surrounding texels and performs bilinear interpolation
// A---------B
// |         |    where x is a position between texels A,B,C,D
// |  x      |  retval = lerp(lerp(A,B,xpos), lerp(C,D,xpos), ypos);
// |         |
// C---------D
void bilerp(in vec2 coord, out vec4 retval)
{
	ivec2 botleft  = ivec2(coord);
	ivec2 botright = botleft + ivec2(1,0);
	ivec2 topleft  = botleft + ivec2(0,1);
	ivec2 topright = botleft + ivec2(1,1);

	vec2 subpixelCoord = coord - vec2(botleft);

	vec4 xlerpbot = mix(imageLoad(inDyeTex, botleft), imageLoad(inDyeTex, botright), subpixelCoord.x);
	vec4 xlerptop = mix(imageLoad(inDyeTex, topleft), imageLoad(inDyeTex, topright), subpixelCoord.x);
	vec4 ylerp = mix(xlerpbot, xlerptop, subpixelCoord.y);

	retval = ylerp;
}

void main(void)
{
	ivec2 curCoord = ivec2(gl_GlobalInvocationID.xy);
	vec2 velocityVec = 2 * (imageLoad(velocityField, curCoord).rg - vec2(0.5,0.5));
	vec2 oldCoord = curCoord - deltaTime * velocityVec; //grabs old coord from back in time

	//set newDyeTexel to either bilerp(oldCoord) or imageLoad(inDyeTex, ivec2(oldCoord))
	vec4 newDyeTexel;
	bilerp(oldCoord, newDyeTexel);
	newDyeTexel = newDyeTexel * dissipation;

	imageStore(outDyeTex, curCoord, newDyeTexel);
}